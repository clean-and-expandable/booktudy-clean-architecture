#6주차

# 클린 아키텍처

- 육각형 아키텍처, DCI(Data, Context and Interaction), BCE(Boundary-Control-Entity) 의 목표는 모두 관심사의 분리(separation of concerns)다. 모두 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다.
- 다음과 같은 특징을 갖는다.
    - 프레임워크 독립성
    - 테스트 용이성
    - UI 독립성
    - 데이터베이스 독립성
    - 모든 외부 에이전시에 대한 독립성

### 의존성 규칙

- 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

### 엔티티

- 엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다.
- 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 된다.

### 유스케이스

- 유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함한다. 또한 유스케이스 계층의 소프트웨어는 시스템의 모든 유스케이스를 캡슐화하고 구현한다.
- 이 계층에서 발생한 변경이 엔티티에 영향을 줘서 안 된다.
- 유스케이스 계층은 이러한 관심사로부터 격리되어 있다.
- 하지만 운영 관점에서 애플리케이션이 변경된다면 유스케이스가 영향을 받으며, 따라서 이 계층의 소프트웨어에도 영향을 줄 것이다.

### 인터페이스 어댑터

- 인터페이스 어댑터 계층은 일련의 어댑터들로 구성된다.
- 이 계층은 데이터를 엔티티ㅗ아 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임의의 프레임워크(즉, 데이터베이스)가 이용하기에 가장 편리한 형식으로 변환한다.
- 이 계층에는 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요하다.

### 원은 네 개여야만 하는가?

- 소스 코드 의존성은 항상 안쪽을 향한다. 안쪽으로 이동할수록 추상화와 정책의 수준은 높아진다. 가장 바깥쪽 원은 저소준의 구체적인 세부사항으로 구성된다. 그리고 안쪽으로 이동할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다. 따라서 가장 안쪽 원은 가장 범용적이며 높은 수준을 가진다.

### 경계 횡단하기

- 제어흐름과 의존성의 방향이 명백히 반여야야 하는 경우, 대체로 `의존성 역전 원칙` 을 사용하여 해결한다. 예를 들어, 자바 같은 언어에서는 인터페이스와 상속 관계를 적절하게 배치함으로써, 제어흐름이 경계를 가로지르는 바로 그 지점에서 소스 코드 의존성을 제어흐름관느 반대가 되게 만들 수 있다.
- 직접 호출해 버리면 의존성 규칙을 위배하기 때문에 유스케이스가 내부 원의 인터페이스를 호출하도록 하고, 외부 원의 프레젠터가 그 인터페이스를 구현하도록 만든다.

# 프레젠터와 험블 객체

- 프레젠터는 험블객체 패턴을 따른 형태로 아키텍처 경계를 식별하고 보호하는 데 도움이 된다.

### 험블 객체 패턴

- 험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.
- 행위들을 두 개의 모듈 또는 클래스로 나눈다. 이들 모듈 중 하나가 `험블` 이다. 가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다.

### 프레젠터와 뷰

- 뷰는 험블 객체이고 테스트하기 어렵다.
- 프레제너는 테스트하기 쉬운 객체이다. 프레젠터의 역할은 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것이다. 이를 통해 뷰는 데이터를 화면으로 전달하는 간단한 처리하도록 만든다.
- 화면에 표시되고 애플리케이션에서 어느 정도 제어할 수 있는 요소라면 무조건 뷰 모델 내부에 문자열, 불 또는 열거형 형태로 표현한다.

### 테스트와 아키텍처

- 테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려져 왔다.

### 데이터베이스 게이트웨이

- 유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이가 위치한다.
- 유스케이스 계층은 SQL을 허용하지 않는다.
- 유스케이스 계층은 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출한다.
- 인터페이스의 구현체는 데이터베이스 계층에 위치하며 험블 객체다.
- 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기 때문에 험블 객체가 아니다.
- 게이트웨이는 스텁이나 테스트 더블로 적당히 교체할 수 있다.

### 데이터 매퍼

- 객체는 데이터 구조가 아니기 때문에 ORM 같은 건 사실 존재하지 않는다.
- 데이터 구조는 함축된 행위를 가지지 않는 public 데이터 변수의 집합이므로 ORM 보다는 차라리 데이터 매퍼라고 부르는 편이 낫다.
- ORM은 데이터베이스 계층이다.

### 서비스 리스너

- 애플리케이션은 데이터를 간단한 데이터 구조형태로 로드한 후 이 데이터 구조를 경계를 가로질러서 특정 모듈로 전달한다.
- 서비스 리스너가 서비스 인터페이스로부터 데이터를 수신하고 데이터를 애플리케이션에서 사용할 수 있게 간딴한 데이터 구조로 포맷을 변경한 후 데이터 구조는 서비스 경계를 가로질러서 내부로 전달하기 때문에 험블 객체 패턴이 존재한다.

### 결론

- 경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리될 것이다. 그리고 이러한 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.

## 부분적 경계

- 아키텍처를 유지하고 보수하는데 엄청난 노력과 수고가 들어간다. YAGNI(You Aren`t Going to Neet It) 원칙을 위배한는지 고민하고 부분적 경계를 고민해본다.
- 마지막 단계를 건너뛰기

### 일차원 경게

- 완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다. 양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.
- 쌍방향 인터페이스가 없고 개발자와 아키텍트가 근면 성실하고 제대로 훈련되어 있지 않다면, 비밀 통로가 생기는 일을 막을 방법이 없다.

### 퍼사드

- 단순한 경계는 퍼사드 패턴이고 의존성 역전까지도 희생한다.
- Client가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다.

### 결론

- 아키텍처 경계가 언제, 어디에 존재해야 할지, 그리고 그 경계를 완벽하게 구현할지 아니면 부분적으로 구현할지를 결정하는 일 또한 아키텍트의 역할이다.

# 계층과 경계

- 아키텍처 경계가 어디에나 존재한다.
- 아키텍트로서 우리는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야 한다. 또한, 이러한 경계를 제대로 구현하려면 비용이 많이 든다는 사실을 인지하고 있어야 한다.
- 추상화가 필요하리라고 미리 예측해서는 안된다.
- 오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많다.
- 어떤 아키텍처 경계도 존재하지 않는 상황에서 경계가 정말로 필요하다는 사실을 발견한 경우, 그때서야 경계를 추가하려면 비용이 많이 들고 큰 위험을 감수해야 한다.
- 현명하게 추측해야하고, 비용을 산정하고, 아키텍처 경계를 둬야할지 고민하고, 완벽하게 구현할 경계는 무엇인지와 부분적으로 구현할 경계와 무시할 경계는 무엇일지를 결정해야 한다.
- 일회성 결정이 아닌 끊임없이 지켜보고 주의를 기울여 결정된 사항을 자주 검토해야 한다.
- 목표는 경계의 구현 비용이 그걸 무시해서 생기는 비용보다 적이지는 바로 그 변곡점에서 경계를 구현하는 것이다.

# 메인 컴포넌트

- 모든 시스템에는 최소한 하나의 컴포넌트가 존재하고, 이 컴포넌트가 나머지 컴포넌트를 생성하고, 조정하며 관리한다. 이를 메인이라고 부른다.

### 궁극적인 세부사항

- 메인 컴포넌트는 궁극적인 세부사항으로 가장 낮은 수준의 정책이다. 메인 시스템의 초기 진입점이다.
- 메인은 모든 팩토리와 전략, 그리고 시스템 전반을 담당하는 나머지 기반 설비를 생성한 후, 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘기는 역할을 맡는다.
- 의존성 주입 프레임워크를 이용해 의존성을 주입하는 일은 바로 이 메인 컴포넌트에서 이뤄져야 한다.
- 메인을 지저분한 컴포넌트 중에서도 가장 지저분한 컴포넌트다.
- 메인은 클린 아키텍처에서 가장 바깥 원에 위치하는, 지저분한 저수준 모듈이다. 메인은 고수준의 시스템을 위한 모든 것을 로드한 후 제어권을 고수준의 시스템에게 넘긴다.

### 결론

- 메인을 애플리케이션의 플러그인이라고 생각해야한다.
- 메인은 초기 조건과 설정을 구성하고, 외부 자원을 모두 수집한 후 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인이다.
- 메인을 플러그인 컴포넌트로 여기고, 그래서 앜키텍처 경계 바같에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.

# `크고 작은 모든` 서비스들

- 서비스 지향 아키텍처와 마이크로서비스 아키텍처가 인기를 끄는 이유는 다음과 같다.
    - 서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다. 일부만 맞는 말이다.
    - 서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다. 일부만 맞는 말이다.
- 서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하는 것이 아니며 시스템의 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.
- 단순히 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하며, 아키텍처 관점에서 꼭 중요하다고 볼 순 없다.

### 서비스의 이점?

- 결합 분리의 오류
    - 시스템을 서비스들로 분리함으로써 얻게 되리라 예상되는 큰 이점 하나는 서비스 사이의 결합이 확실히 분리된다는 점이다. 하지만 꼭 그런 것은 아니다. 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재한다. 더욱이 서로 공유하는 데이터에 의해 이들 서비스는 더우 깡력하게 결합되어 버린다.
    - 인터페이스가 잘 정의되어ㅑ 있어야 한다는 이점에 대해서라면 이는 명백히 사실이다. 서비스 인터페이스가 함수 인터페이스보다 더 엄밀하거나 더 엄격하고 더 잘 정의되는 것은 아니다.
- 개발 및 배포 독립성의 오류
    - 대규모 엔터프라이즈 시스템은 서비스 기반 시스템 외에도 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있다는 사실은 역사적으로 증명되어 왔다.
    - 결합 분리의 오류에 따르면 서비스라고 해서 항상 독립적으로 개발하고, 배포하며, 운영할 수 있는 것은 아니다.

### 야옹이 문제

- 기존에 존재하는 택시 구조에 야옹이를 배달하는걸 추가하면 어떻게 해결할 수 있을까

### 객체가 구출하다

- 컴포넌트 기반에서는 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 하였다.
- 기존 컴포넌트들에 있는 추상 기반 클래스들을 템플릿 메서드나 전략 패턴 등을 이용해서 오버라이드한다.
- 기능들을 구현하는 클래스들은 UI의 제어하여 팩토리가 생성하도록 한다.

### 횡단 관심사

- 아키텍처 경계가 서비스 사이에 있지 않다.
- 오히려 서비스를 관통하며 서비스를 컴포넌트 단위로 분할한다.
- 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.
- 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트이다.

### 결론

- 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.
- 시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 드나드는 의존성에 의해 정의된다. 시스템의 구성 요소가 통신하고 실행되는 물리적인 메커니즘에 의해 아키텍처가 정의되는 것이 아니다.

# 테스트의 경계

- 테스트는 시스템의 일부이며 아키텍처에도 관여한다.

### 시스템 컴포넌트인 테스트

- 테스트는 태생적으로 의존성 규칙을 따른다.
- 시세틈 내부의 어떤 것도 테스트에는 의존하지 않으며 테스트는 시스템의 컴포넌트를 향해 항상 원의 안쪽으로 의존한다.
- 테스트는 독립적으로 배포 가능하다.
- 테스트는 시스템 컴포넌트 중에서 가장 고립되어 있다.

### 테스트를 고려한 설계

- 테스트가 시스템의 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고, 시스템은 뻣뻣해져서 변경하기 어려워진다.
- 문제는 결합이다. 시스템에 강하게 결합된 테스트라면 시스템이 변경될 때 함께 변경되어야 한다.
- 이러한 것은 `깨지기 쉬운 테스트 문제` 로 알려져 있다.
- 테스트 설계는 소프트웨어 설계의 첫 번째 규칙과 같다. `변동성이 있는 것에 의존하지 말라.`

### 테스트 API

- 테스트가 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 API를 만들면 된다.
- 사용자 인터페이스가 사용하는 인터렉터와 인터페이스 어댑터들의 상위 집합이 될 것이다.
- 테스트 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다.
- 테스트 구조를 애플리케이션 구조로부터 결합을 분리하는게 목표다.

### 구조적 결합

- 구조적 결합은 테스트 결합 중에서 가장 강하며, 가장 은밀하게 퍼져 나가는 유형이다.
- 테스트 API 의 역할은 애플리케이션의 구조를 테스트로부터 숨기는데 있다.

### 보안

- 테스트 API 자체와 테스트 API 중 위험한 부분의 구현부는 독립적으로 배포할 수 있는 컴포넌트로 분리해야 한다.

### 결론

- 테스트는 시스템 외부에 있지 않다. 오히려 시스템의 일부다. 따라서 테스트에서 기대하는 안정성과 회귀의 이점을 얻을 수 있으려면 테스트는 잘 설계 되어야 한다.