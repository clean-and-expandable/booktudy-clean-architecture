# 3주차

## 개요

SOLID는 좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 필요하다.

SOLID의 원칙은

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

SRP : 단일 책임의 원칙(Single Responseibility Principle)

- 각 소프트웨어 모듈은 변경 이유가 하나, 단 하나여야만 한다.

OCP : 개방-폐쇄 원칙(Open-Closed Principle)

- 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.

LSP: 리스코드 치환 원칙(Liskov Substitution Principle)

- 상호 대체 가능한 구성요소를 이용ㅇ해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.

ISP: 인터페이스 분리 원칙(Interface Segregation Principle)

- 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.

DIP: 의존성 역전 원칙(Dependency Inversion Principle)

- 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다.

## SRP

- SRP는 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
    
    

`응집된` 이라는 단어가 SRP를 암시하며 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.

이 책의 장점 중 하나는 잘못된 사례를 토대로 무엇이 잘못됐고, 어떻게 해결해 나가는지를 설명해주는 것이라고 생각한다. 

징후1: 우발적 중독에서보면 여러 액터가 동일한 기능을 바라보는 구조가 되면서 요구사항이 액터마다 변경됨에 따른 문제가 발생하는 케이스인데, 쉽게 볼 수 있는 구조라고 생각한다. 실제로 많이 보기도 했고, 현재 남아있는 경우가 대부분이다. 이러한 경우에는 SRP를 위배하므로 `서로 다른 액터가 의존하는 코드를 서로 분리해야 한다.`

또한, 클래스와 메서드를 액터에 따라 분리를 하여 액터 클래스들가 서로의 존재를 몰라야 `우연한 중복` 을 피할 수 있다. 하지만 클래스들을 인스턴스화하고 추척해야 한다는 단점이 있지만, Facade 패턴 형태로 해결 가능하다.

단일 책임 원칙은 메서드와 클래스 수준의 원칙이지만 컴포턴트와 아키텍처의 수준도 존재한다.

## OCP

- 소프트웨어 개체는 확자에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
    
    

소프트웨어 아키텍처를 공부하는 가장 근본적인 이유가 바로 이 때문이며 수정을 쉽게 해주는 요소이다.

결국 업무 규칙을 포함하고 있는 요소(가장 높은 수준의 정책을 포함)는 가장 높은 수준의 개념이며 최고의 보호를 받아야 한다. 그렇게 점점 낮은 수준으로 지켜져야 하며 이러한 형태가 OCP가 동작하는 방식이다.

기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 긴으을 컴포넌트의 계층구조로 조직화한다. 따라서 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있어야 한다.

이러한 고수준 컴포넌트를 지키기 위해서는 구체적인 클래스가 아닌 인터페이스를 바라보도록 설계를 해야하며 의존성간의 제대로 된 방향으로 향해야 한다.

또한 직접적인 의존성뿐만 아니라 A→ B → C와 같은 A가 C의 추이 종속성을 가지지 않도록 설계하는 것도 중요하다. 추이 종속성을 가지면 소프트웨어 엔티티는 `자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다.` 는 소프트웨어 원칙을 위반하게 된다.

고수준의 컴포넌트가 저수준의 변경으로부터 보호하는 일이 최우선이지만, 반대로 고수준의 변경으로부터 저수준도 보호되어야 한다. 이를 위해 고수준을 은닉해야한다.

OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다. 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 게층구조가 만들어지도록 해야 한다.

## LSP

- S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
    
    

LSP는 인터페이스 뿐만아니라 REST와 같이 다양한 상황에 적용될 수 있다. 추상적인 기법을 사용해서 쉽게 치환이 가능하도록 설계하는 것이 중요하다.

위배 사례를 보면 누구나 경험할 수 있는 것들인데 상황이나 주체에 따라 조건문만 늘어가는 모습이다. 이러한 것들을 해결하기 위해 많은 복잡한 메커니즘을 추가해야된다.

따라서 LSP는 아키텍처 수준까지 확장할 수 있고 반드시 확장해야만 한다.

## ISP

하나의 인터페이스가 너무 많은 기능을 가지고 있다면 사용하지 않는 기능이 변경될 때마다 모든 인터페이스를 구현하는 구현체가 변경되어 배포가 되어야 한다.

이러한 것들은 언어와 연관되어 있으며 동적 언어는 이러한 문제를 해결할 수 있다.

필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 소스 코드 의존성의 경우 불필요한 재컴파일과 재배포를 강제하기도 한다.

물론 고수준의 프레임워크 사이에서도 발생하는 현상이다.

불필요한 짐을 실은 무언가에 의존하면 예상치 못한 문제에 빠지게 된다.

### DIP

- 유연성이 극대화된 시스템이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
    
    

DIP를 논할 때 운영체제나 플랫폼 같이 안전성이 보장된 환경에서는 무시가 되기도 한다. 하지만, 대부분의 소프트웨어는 변동성이 크며 이러한 변동성이 큰 구체적인 요소들은 의존해서는 안된다.

뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스의 변동성을 낮추기 위해 애쓴다. 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력한다. 

즉, 안정된 소프트웨어 아키텍처란 `변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.`

- 변동성이 큰 구체 클래스를 참조하지 말라.
- 변동성이 큰 구체 클래스로부터 파생하지 말라.
- 구체 함수를 오버라이드 하지 말라.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

대부분의 언어에서 이러한 구체적인 의존성을 가져가지 않도록 하기 위해 `팩토리` 를 사용하곤 한다.

팩토리는 곡선(아키텍처 경계)은 구체적인 것들로부터 추상적인 것들을 분리하도록 한다. 소스 코드 의존성은 해당 곡선과 교차할 때 두 한 방향, 즉 추상적인 엔티티 쪽으로 향한다.

제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지르며 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다. 이러한 원칙을 `의존성 역전` 이라고 부른다.

수준이란?

- 사용자에게 가장 가까운 부분, 변경이 많이 발생하는 부분, 가장 보호받지 못하는 부분