
좋은 소프트웨어 시스템은 깔끔한 코드로부터 시작한다.

SOLID를 잘 사용하면 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 있다.

- 변경에 유연하다
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

중간 수준이란, 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다.

SOLID를 잘 이해하면, 고수준의 아키텍처까지 이해할 수 있을것이다.

고수준 → 도메인에 가까운

저수준 → 뷰에 가까운 ( 사용자에게 가까운 )

## SRP

하나의 함수는 반드시 하나의 일만 해야 한다는 뜻이다. 하지만 이것이 SRP는 아니다.

SRP는 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이여야 한다. 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

액터는 개발자에게 일을 시키는 사람일 수 있다.

SRP를 쪼개는것은 매우 어려운 일인것 같다.

클래스의 네이밍을 만들어서, 이 네이밍의 이상일을 하면 그것은 SRP을 지킨것을 보기 어려운것 같다.

## OCP

소프트웨어 아키텍처를 공부하는 이유는 요구사항을 살짝 확장하는데 소프트웨어를 엄청나게 수정하지 않기 위해서이다.

만약 기존 기능이 있는데, 비슷하지만 새로운 기능을 추가하는데 드는 비용은 몇일까?

SRP로 잘 나누었고, 객체 사이에 인터페이스를 사용하여 DIP를 했으면 0에 가깝다.

## LSP

리스코프 치환 원칙은 상속을 받아도 부모와 자식간 언제든 치환이 가능하다는 로직이다.

예를들어 정사각형이 있는데, 직사각형 클래스를 만들기 위해 정사각형을 상속받으면 그건 이슈이다.

왜냐면 직사각형은 가로,세로가 틀릴 수 있기 때문이다.

LSP는 처음에 상속에 대한 이야기였지만, 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해 왔다.

## ISP

OPS라는 구현체가 op1, op2, op3라는 인터페이스를 구현하고 있고, User1은 op1의 기능만, Usr2는 op2의 기능만, User3는 op3의 기능만 쓴다고 가정한다.

User1은 op2,3를 쓰지 않지만 알고 있어야하고, 나머지도 마찬가지다.

op2의 소스코드가 변경되어 배포되면 User1도 컴파일 후 새로 배포해야 한다.

이럴떈 User1은 op1의 인터페이스만 가지고 프로그램을 작성하면 된다.

## DIP

import 같은것은 인터페이스나 추상 클래스만 선언이 되어야하고, 구체적인 대상에는 절대로 의존해서는 안된다.

반면 String 같은 클래스는 변경되는 일이 거의 없기 때문에, 사용해도 된다.

인터페이스가 변경이 되면 구체화된 구현체들도 변경해야 한다.

반대로 구체적인 구현체에 변경이 생기더라도 구현체가 구현하는 인터페이스는 변경이 필요 없다.

한마디로 인터페이스는 구현체보다 변동성이 낮다.

실제로 뛰어난 아키텍트라면 인터페이스의 변동성을 낮추기 위해 노력한다.

안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일을 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.

변동성이 큰 구체 클래스를 참조하지 말고, 변동성이 큰 구체 클래스로부터 파생하지 말아야 한다.

그리고 구체 함수를 오버라이드 하지 말아야 한다.

Framework레벨에서 제공하는 DI를 사용하지 못한다면, 구현클래스가 있는 Module에다가 구체 컴포넌트 하나를 만들고, 인터페이스 타입으로 변환하여 리턴해주는 팩터리 클래스가 있어야 한다.
