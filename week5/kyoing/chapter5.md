고수준 = 도메인, 저수준 = 애플리케이션 ?

소프트웨어 아키텍트라면 코드에서 탈피하여 고수준의 문제에 집중해야 한다는 거짓말에 속으면 안됨.

형편없는 코드는 잘 동작하지만, 배포 유지보수 계속되는 개발 과정에서 어려움을 겪는다.

개발하기 힘든 시스템은 수명이 길지 않고, 건강하지도 않다. 그래서 시스템 아키텍처는 개발팀들이 시스템을 쉽게 개발할 수 있도록 뒷바침 해야 한다.

개발자가 얼마 없으면 잘 정의된 컴포넌트와 인터페이스가 없더라도 서로 효율적으로 협력하여 모놀리딕 으러 개발이 가능하다. 이러한 팀은 오히려 아키텍처 같은 제약이 방해될 수 있다.

⇒ 아키텍처가 답은 아니다.

배포는 잘 되어야 하고, 배포 비용이 높을수록 시스템의 유용성은 떨어진다. 아키텍처는 한번에 쉽게 배포할 수 있도록 만드는데 목표를 둬야 한다.

개발 초기에 MSA를 사용할 경우 안정화된 시스템을 쉽게 개발할 수 있다고 생가할지 몰라도. 배포를 시작하면 큰 문제가 발생할 수 있다.

시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 한다.

모든 소프트웨어 시스템은 정책과 세부사항으로 이루어져 있다.

정책은 모든 업무 규칙과 업무 절차를 구체화 한다. ⇒ 도메인

세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다.

아키텍트의 목표는 시스템에서 정책을 가장 핵심적으로 선정하고, 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다.

(개발초기에 DB선택 X, 개발 초기에 웹서버 선택 X, 개발 초기에 Rest 적용 필요 X, 개발 초기 DI프레임워크 선택 X)

**결국 고수준이 저수준을 해쳐서는 안된다.**

시스템이 장바구니 애플리케이션이라면, 이 아키텍처는 바구니와 관련된 **유스케이스를** 지원해야 한다.

좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고, 외부로 드러나며, 이를 통해 시스템이 지닌 의도를  아키텍처 수준으로 알아볼 수 있도록 하는것.

⇒ 아키텍처를 통해 이 어플리케이션이 무슨 일을 하는지 알 수 있어야함.

많은 팀이 시스템을 만든다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로 방해되지 않게 해야한다. 이러한 아키텍처를 만들려면 잘 격리되고, 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.

좋은 아키텍처는 작은 설정 스크립트나 속성 파일을 수정하는 방식을 사용하지 않고, 수작업으로 작업하는게 없게 한다. 바로 배포할 수 있어야 한다.

**사용자 인터페이스가 변경되는건 업무 규칙과는 아무런 관련이 없다.**

유스케이스에서 UI부분과 업무 규칙 부분을 서로 분리해야한다.

입력 필드 검사는 애플리케이션의 규칙이다. 계쫘의 이자 계산이나 재고품 집계는 업무 도메인에 밀접한 업무 규칙이다. 이들 서로 다른 두 유형의 규칙은 각자 다른 속도로, 그리고 다른 이유로 변경된다.

데이터베이스 쿼리 언어 심지어 스키마조차도 기술적인 세부사항이다.

주문을 추가하는 유스케이스는 주문을 삭제하는 유스케이스와는 다른속도로 개발되ㅣ고, 변경된다.

유스케이스는 시스템의 수평적인 계층을  가로지르도록 자른, 수직으로 자른 조각이다.

각 유스케이스는 UI 일부, 애플리케이션 특화 업무 규칙의 일부, 애플리케이션 독립적 업무 규칙의 일부, 그리고 데이터베이스 기능의 일부를 사용한다.

주문 추가 유스케이스UI와 주문 삭제 유스케이스 UI를 분리해야 한다. 이렇게 하면 서비스, 데이터베이스도 나누게 된다. 기존 요소에 지장을 주지 않고도 새로운 유스케이스 추가가 가능하다.

높은 처리량이 필요한 유스케이스와, 낮은 처리량으로도 충분한 유스케이스 분리가 가능하고, UI와 디비는 다른 서버에서 처리가 가능하다. 그리고 해당 유스케이스는 여러서버로 복제 가능하다.

결국 이것은 웅여ㅕㅇ에 도움이 된다.

아키텍트는 중복의 함정에 빠진다. 진짜 중복과 가짜 중복이다.

한 인스턴스가 변경되면 다른 인스턴스도 모두 변경되어야 한다.

가짜 중복은 나중에 다라질 수 있는것이다.

처음엔 같은 화면인데 이거는 중복일까? 나중엔 당연히 달라진다 이런것은 통합하지 않도록 해야하고, 중복이 진짜 중복인지 확인 해야 한다.

좋은 아키텍처는 시스템이 모노리틱으로 태어나서 단일 배폭가되어도, 나중엔 독립 배포할 수 있도록 해야하고, MSA로 성장할 수 있도록 해야 한다.

인터페이스만으로 가지고 기능이 구현이 가능하다. 스텁으로 말이다.

나중에 필요하면 인메모리 디비를 써도 되고 나중엔 다른걸로 바꿔도 된다.

결국 도메인에 집중해야 한다.

고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다향성을 사용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있다

저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계해야한다.

시스템의 입력과 출력 부터 멀어지면 정책의 수준이 높아진다.

엔티티 객체는 핵심 업무 데이터를 직접 포함하거나 핵심 업무 데이터에 매우 쉽게 접근할 수 있다.

이 클래스는 데이터베이스, 사용자 인터페이스, 서드파티 프레임워크에 오염되어서는 안된다,.

아키텍처는 헬스케어 시스템이야, 재고 관리 시스템이야 라고 소리를 쳐야지, 스프링이야 하이버네이트야 ASP라고 서리를 치면 안된다.

유스케이스 주도 접근법이라는것도 공부해보자.

좋은 아키텍처는 유스케이스를 중심에 두기에 프레임워크 도구 환경에 전혀 구애받지 않고 기술을 쓸 수 있다.

아키텍트는 외장재를 소유주가 결정할 수 있도록 애쓰지만, 이 여깃도 계획서가 유스케이스를 확실히 충족시킨 이후다.

결국 도메인이 튼튼해야 외장재 선택을 맡기는거다.

아키텍처가 유스케이스를 최우선으로 한다면, 그리고 프레임워크와는 적당한 거리를 두면 프레임워크 없이 전부 단위테스트가 가능하다.

아키텍처는 시스템을 이야기 해야하며, 시스템의 프레임워크에 대해 이야기하면 안된다.
