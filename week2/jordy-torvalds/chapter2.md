#2부 벽돌부터 시작하기: 프로그래밍 패러다임

# 여는 글

2부는 총 세 장으로 이뤄져있으며 각 장의 주제는 아래와 같습니다.

- 3장. 패러다임 개요
- 4장. 구조적 프로그래밍
- 5장. 객체 지향 프로그래밍
- 6장. 함수형 프로그래밍

# 3장. 패러다임 개요

패러다임은 더 나은 아키텍처가 될 수 있도록 하기 위해 기존 권한에 추가적인 권한을 부여하지 않고, 오히려 권한을 박탈하고 규칙을 부여한다.

**구조적 프로그래밍**은 프로그램 구조를 해롭게하는 goto문을 박탈하고 조건문, 반복문, 제어문를 대체해서 사용하도록 했다.

**객체 지향 프로그래밍**은 함수 호출 스택 프레임을 힙 메모리 공간으로 옮긴다는 아이디어에 착안해서 클래스의 생성자와 인스턴스 변수, 메소드을 만들었다. 

**함수형 프로그래밍**은 수학적 문제를 해결하는 과정에서 발명한 람다에서 영향을 받아 만들어진 패러다임이다. 주요 특징은 불변성으로 함수 밖에 변수의 변경에 대해 제약을 줬다.

이렇듯 자유로움에서 권한을 박탈하고 규칙을 부여함으로써 개발될 소프트웨어가 더 좋은 아키텍처를 가질 수 있도록 한다.

패러다임에 있어 한 가지 오해가 있다면 하나의 언어가 하나의 패러다임만을 가지는 것은 아니라는 점이다. 최근 자바의 경우에는 객체 지향 언어로 시작을 했으나 현재는 함수형 패러다임에 대한 규칙도 많이 생겨남에 따라 두 패러다임에 장점을 모두 취함으로써 더 나은 아키텍처를 가진 소프트웨어가 개발될 수 있게 돕고있다.

# 4장. 구조적 프로그래밍

goto문은 프로그래밍 흐름을 제어하는데 사용되었던 기능이다. 이 기능도 좋은 패턴과 나쁜 패턴이 있었는데 프로그래밍 흐름을 해칠 수 있는 나쁜 패턴을 제외하고 좋은 패턴만 추출 했을 때만 추출 해 정리한 것이 **조건문**과 **반복문**이다. 프로그래밍의 대부분의 흐름은 이 순차적인 흐름 외에 조건문과 반복문으로 모두 표현 가능함이 당시에 증명되었다.

자바의 break문도 goto 문과 같이 프로그래밍 흐름을 직접적으로 제어하는 기능이 아니냐는 의견도 있었으나 그 사용이 반복문 내로 한정한다는 제약이 있기 때문에 기존의 goto문에 비교해 큰 문제가 되지 않는다.

구조적 프로그래밍을 통해 특정 문제 해결을 위한 거대한 프로그램을 컴포넌트와 기능 단위로 분리할 수 있게 되면서 더욱 간결하고 가독성있게 소프트웨어를 표현할 수 있게 되었다.

저자는 테스트를 수학이 아닌 과학과 유사한 점이 있음을 말하기도 했다. 과학은 한 가지에 대해 옳음을 증명할 순 없지만 틀림거나 잘못되었음을 밝혀낼 수 있다는 특성이 있다.

이와 비슷하게 소프트웨어는 테스트를 통해 완벽히 동작함을 완벽히 증명할 수는 없으며 어디까지나 요구사항과 목표에 맞게 동작함만을 보장해준다. 다시 말해, 테스트를 통해 올바르지 않음을 증명하는데 실패함으로써 그 가치를 증명할 수 있다.

# 5장. 객체 지향 프로그래밍

OO 언어의 최소한의 자격 조건은 총 세 가지 이다. 캡슐화, 상속, 다형성. 하나씩 알아보자!

**캡슐화**란? 구분서 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출하는 것을 말한다. 접근지정자는 완전한 캡슐화를 보장해주지는 못하며 믿음에 좀 더 가깝다.

**상속**이란? 어떤 함수나 변수를 하나의 유효 범위로 묶어서 재정의하는 것.

**다형성**이란? 하나의 객체가 여러 가지 타입을 가질 수 있음을 의미합니다. 책에서 소개하는 플러그인 아키텍처가 이와같은 원리인데 직접적인 의존관계가 없으므로 플러그인 규칙에 맞게 구현이 된 장치는 얼마든지 대체가 가능하다는 원리이다. 

![image](https://user-images.githubusercontent.com/58139899/147716316-1576e175-c00f-4fca-a2bc-7067317fc6be.png)

출처: 위키피디아

의존성 역전은 다형성을 편리하게 적용하기 위한 방법 중 하나이다.  의존성 역전을 사용함으로써 소스코드는 클라이언트 클래스가 인터페이스와 의존 하지만 실제 프로그램 실행 시점에는 클라이언트 클래스가 그 구현체 중 하나를 의존하게 되는 것이다. 결론적으로 소스코드의 의존성이 제어 흐름과 방향이 일치되도록 제한되지 않고 원하는 대로 정의할 수 있게 되었다.

# 6장. 함수형 프로그래밍

가변한 상태는 레이스 컨디션, 데드락, 동시 업데이트와 같은 동시성 문제를 발생시키는 주요 원인이다. 그러나 함수형 언어는 변수가 사용되지 않기 떄문에 이점에 있어 자유롭다. 이에 더하여 동일한 인풋에 대해 항상 동일한 결과를 보장한다.

그렇다고 변수를 완전히 사용하지 않을 수는 없다. 그래서 불변 영역과 가변 영역을 분리함으로써 그 문제 포인트를 집중화 하면서 동시에 최적화 할 수 있다.  그렇게 되면 가변 클래스 내에서 주요한 변수는 여전히 레이스 컨디션, 데드락, 동시 업데이트와 같은 문제에 여전히 노출되어 있는데 이는 latch 나 lock, 그리고 atomic한 자료 구조를 사용함으로써 문제를 해결하면서도 동시 접근시 일부 쓰레드의 대기로 인해 발생하는 성능 문제를 최소화할 수도 있다.

불변 영역과 가변 영역을 분리와 가변성을 불변성으로 전환하는 것이 함수형 패러다임의 장점을 취하는 가장 좋은 방법으로 정리할 수 있다. 이를 따르는 패턴이 CQRS와 이벤트 소싱이다. CQRS는 변경을 일으키는 명령과 변경 없이 데이터를 읽어 오기만 하는 조회를 분리하는 패턴을 말하고 이벤트 소싱은 직접적인 데이터 변경을 LOG APPEND 방식의 상태 변경 없는 삽입으로 전환함으로써 동시성 문제를 해결했다.

한 마디로 함수형 프로그래밍은 제약과 규칙을 통해 가변한 상태로 생기는 부작용을 해결하는 패러다임으로 정리할 수 있다.

# 닫는 글

각 패러다임의 제한과 규칙 부여가 무엇이 있고 이것이 가져오는 아키텍처 순효과에 대해 알아보았다. 개인적으로 느끼기엔 제한과 규칙은 일종에 좋은 아키텍처로 나아가기 위한 나침판이란 생각이 들었다.
