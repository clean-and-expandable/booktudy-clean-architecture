소프트웨어 아키텍처는 코드로 부터 시작된다. 따라서 아키텍처에 대한 논의도 코드가 최초로 작성된 시점부터, 우리가 코드를 통해 배운 내용을 살펴보는 데서 출발하고자 한다.

프로그래머는 프로그래밍을 잘 하지 못한다. 모든 프로그램은 단순할지라도, 인간의 뇌로 감당하기에 너무 많은 내용을 가지고 있다.

프로그램은 순차, 분기, 반복 이라는 세가지 구조만으로 표현이 가능하고, 이것을 토대로 구조적 프로그래밍을 만들었다. 현재 우리 모두는 구조적 프로그래머이며, 제어흐름을 직접 제어할 수 있도록 언어에서 제공하지 않는다.

프로그램이 잘못됬음을 테스트를 통해 증명이 가능하지만, 프로그램이 맞다고 증명할 수 는 없다.

OO를 실제 설계를 모델링 하는 새로운 방법이라고 답한다면 이상한 대답이다.

완벽한 캡슐화는 함수의 시그니처만을 가지고 코딩을 할 수 있어야 한다. C에서의 h파일만 가지고 코딩하는것 처럼 말이다.

OO 프로그래밍은 프로그래머(제 3자)가 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다.

OO는 캡슐화에 대해서는 점수를 줄 수 없고, 상속에 대해서는 0.5점 정도 줄 수 있다.

캡슐화는 오히려 C에서 잘 되고 있었고, OO언어가 고안되기도 전에 상속이라는 개념이 있었다.

다형성이라고 하면 답이 맞을것 같다.

입출력에 대한 인터페이스만 정의를 하면, 언제든지 입출력을 변경할 수 있다.

서버를 다시 배포하지 않고도 말이다.

그리고 다형성을 통해 의존성 역전도 가능하게 하며, 이것이 아키텍트 관점에서는 엄청난 힘이된다.

의존성 역전 법칙을 사용하면, 각자 독립적으로 배포할 수 있게 된다.

(common모듈에 domain에 사용될 lambda를 넣어두고, api레벨에서 구현하면 domain → api가 될것을 domain ← api가 되게되고, api코드만 배포가 가능하다. 이렇게 되면 도메인은 어디에도 종속되지 않는다.)

변수의 가변성을 걱정해야한다. 경합조건, 교착상태조건, 동시업데이트 문제가 모두 가변 변수때문에 발생하기 때문이다. 만약 어떠한 변수도 갱신되지 않는다면 경합 조건이나 동시 업데이트에 대한 문제가 발생하지 않는다.

불변성과 관련하여 가중 주요한 타협 중 하나는 가변 컴포넌트와 불변 컴포넌트를 분리하는것이다. 불변 컴포넌트는 순순하게 함수형 방식으로만 작업이 되며, 어떤 가변 변수도 사용되지 않는다.

현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 학소, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

계좌 잔고를 변경하는 대신, 트랜잭션 자체를 저장하고, 금액을 얻어올 때 다시 실행시키는 이벤트 소싱 방식도 괜찮다.

이 전략에서는 가변 변수가 하나도 필요 없다.

당연하게 이 방법은 너무 방대해지게 된다. 이 전략은 무한한 저장공간과 무한한 처리 능력이 필요하지만, 애플리케이션 생명 주기동안만 가지고 있게 하면 문제가 없다.

이벤트 소싱이 이것이다.

이 방법은 CRUD가 아닌, CR만 수행하게 된다. 그래서 동시 업데이트에 대한 문제가 발생하지 않는다.
