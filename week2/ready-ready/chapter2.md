# 2주차

## 패러다임의 개요

패러다임은 세 가지가 존재한다. 

1. 구조적 프로그래밍(strctured programming)
2. 객체지향 프로그래밍(object-orented programming)
3. 함수형 프로그래밍(functional programming)

구조적 프로그래밍은 `제어흐름의 직접적인 전환에 대한 규칙을 부과한다.` 

객체 지향 프로그래밍은 `제어흐름의 간접적인 전환에 대해 규칙을 부과한다.`

함수형 프로그래밍은 `할당문에 대해 규칙을 부과한다.`

처음엔 이 3가지의 정의가 어떤 의미인지 전혀 파악하지 못했다. 이럴거란 감은 잡았어도 명확한 해답을 내릴 수 없었다. 나름 책을 읽고 정리해왔다고 생각해왔는데 전혀 파악을 하지 못하니 이 말이 맞는걸까 라는 반감이 먼저 생겼다.

또한, 패러다임은 총 3가지가 전부이고 3가지 이후로는 앞으로 나오지 않을거라는 말이 나와있는데 정말 그럴까? 기술의 발전 속도가 이렇게나 빠른데 과연 그럴까? 라는 의문을 가졌다.

하지만 이 책의 2챕터를 읽고 내 생각이 잘못됐다는 걸 깨달았고 저 규칙들에 대해 이해할 수 있었다.

우선 패러다임은 1958년부터 10년 후인 1968년을 기점으로 새로운 패러다임이 나오지 않았다. 최소 60년이상 동안 새로운 패러다임이 나오지 않았는데, 이 사이에 변경된 많은 것들을 생각해보면 정말 아이러니하다. 

## 구조적 프로그래밍

이 장에서는 저자가 수학적 증명과 과학적 증명, 데이크스트라는 인물에 대한 설명을 장황하게 해주는데 결론으로는 `제약 없는 goto 문은 아무런 제약이 없으며 입증이 불가능하므로 올바르다고 할 수 없다` 와 `소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다` 라는 것이다. 

- 수학은 증명 가능한 서술이 참임을 입증하는 원리라고 볼 수 있다. 반면 과학은 증명 가능한 서술이 거짓임을 입증하는 원리라고 볼 수 있다.
    
    

즉, 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다는 것이다. 이러한 것들을 위해 구조적 프로그래밍과 유사한 제한적인 규칙들이 생겼고 이를 받아들여 활용해야 한다는 것이다.

소프트웨어를 개발하면 테스트 코드를 작성하고 실행시켜봄으로써 동작을 확인해본다. 이러한 과정을 생각해보면 프로그램이 잘못되었음을 계속해서 테스트하면서 증명해나가는 동작이었고, 그 프로그램이 맞다고 증명할 수는 없었다. 역으로 말하면 과연 맞는 프로그램은 존재할까? 없다고 생각한다. 버그는 어떻게 해서든 만들어질 수 있고, 생길 수 있다. 

결국 테스트에 충분한 노력을 들인다는 것은 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이다.

가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다. 

이렇듯 구조적 프로그래밍은 goto 문과 같은 입증 불가능한 것에 제약을 두고 반증 가능하도록(테스트 가능하도록) 직접적인 제한적인 규칙들을 부과한다.

## 객체 지향 프로그래밍

자바를 사용하여 개발하고 있는 개발자라면 객체 지향 프로그래밍에 대해 한번 쯤은 검색해보고 찾아봤을 거라 생각한다. 객체 지향에 대해 검색하면 가장 많이 나오는 것이 캡슐화, 다형성, 상속이다. 수업을 수강하더라도 가장 많이 얘기 나오는 주제이고 이게 맞다고 생각해왔었다. 

하지만 이러한 것들에 대해서 이해하고 적용하는 것만으로도 벅찼었기 때문에 부정해본 적은 없었다. 

### 캡슐화

OO를 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO 언어가 제공하기 때문이다. 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. 이 개념들이 실제 OO 언어에서는 각각 클래스의 private  멤버 데이터와 public 멤버 함수로 표현된다. 

이러한 개념이 OO에만 국한된 것은 아니다. C언어에서도 가능하다. 오히려 C에서는 완벽한 캡슐화가 가능했고 C++ 에서 캡슐화가 깨지게 되었다. 

캡슐화가 깨진다는 말은 무엇일지 생각해보면 완벽한 캡슐화는 데이터 은닉이 완벽화게 되어있어서, 특정 클래스의 기능을 사용할 때 해당 멤버변수가 변경되더라도 사용하는 측에서 변경이 됐는지 몰라야되며 영향을 끼쳐서는 안된다. 

하지만 C++이나 자바에서는 접근제어자를 통해 불완전한 캡슐화를 어느 정도 보완하기는 했지만 컴파일러가 헤더 파일에서 멤버 변수를 볼 수 있어야 했기 때문에 조치한 임시방편일 뿐이다.

따라서, OO가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들며 실제로 많은 OO 언어가 `캡슐화를 거의 강제하지 않는다.` 오히려 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음 기반으로 한다.

### 상속

OO 언어가 더 나은 캡슐화는 제공하지 못했지만 상속만큼은 확실히 제공했다.

물론 OO 언어 이전에도 가능했지만 표현하기 매우 힘들었고, 다중 상속은 더욱 더 힘들었다. OO 에서는 업캐스팅과 다양한 형태로 상속을 쉽게 만들어줬다. 

하지만, 새로운 개념을 만들진 못했고 상속을 편리한 방식으로 사용할 수 있게 해줬다.

### 다형성

다형성도 과연 OO 이전에 있었을까? 답은 있었다.

다형성 또한 새로운 개념이 아니다. 함수를 가리키는 포인터를 응용한 것이 다형성이다.

완전히 옳은 말은 아니지만 OO 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 더욱 편리하게 용할 수 있게 해준다.

C언어나 C++을 공부해본 사람들은 알고있 듯이 포인터를 사용하게되면 메모리에 대한 문제와 신경을 쓸 수 밖에 없다. 이 말은 많은 관례를 지켜야 한다는 것이며 망각하는 순간 버그가 발생할 수 있다는 점이다. 

OO 언어는 이러한 관례를 없애주며, 따라서 실수할 위험이 없다. OO 언어는 이러한 이유로 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.

다형성을 제대로 사용한다고 가정한다면 아무런 변경 없이 새로운 기능을 런타임 시점에 추가할 수 있게 된다. 컴파일도 필요 없으며 소스 코드에 의존하지 않고 추가할 수 있게 된다. 다시 말해 `플러그인` 방식으로 기능을 추가할 수 있게 된다는 것이다.

프로그램은 `장치 독립적` 이어야 한다. `플러그인 아키텍처` 는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.

다형성을 적용하면 가장 얻을 수 있는 의점이 `의존성 역전` 이다.

일반적으로 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를 호출하며, 중간 수준 함수는 다시 저수준 함수를 호출한다. 이러한 호출 트리에서 소스 코드 의존성의 방향은 다시 `제어흐름` 을 따르게 된다.

이러한 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다.

하지만 `다형성` 을 사용하게 되면 함수가 런타임에 존재하지 않는 인터페이스를 호출하게 함으로써 의존성이 제어흐름과는 반대가 된다. 이를 `의존성 역전(dependency inversion)` 이라고 부른다.

이 말은 즉 OO 언어로 갭라된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 `절대적인 관한`을 갖는다는 것이다. 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다. 

이것이 OO가 지향하는 방향이다. 컴포넌트와 소스 코드가 독립되어 `배포 독립성` 을 유지할 수 있으며 팀마다 독립적으로 개발하며 `개발 독립성` 을 유지할 수 있게 된다. 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

## 함수형 프로그래밍

함수형 프로그래밍은 일반 적인 자바 프로그래밍과 극단적인 차이로 가변 변수와 불변 변수이다.

함수형 언어에서 변수는 `변경되지 않는다.`

### 불변성과 아키텍처

경합조건, 교착상태 조건, 동시 업데이트 문제가 모두 가변 변수로 인해 발생한다. 누구나 한번 쯤은 겪어 봤을 문제이고 가장 해결하기 어려운 문제이다. 이러한 문제를 해결하기 위해서 다양한 방법을 고안해보지만 불변성만큼 간단하게 해결해줄 수 있는 것도 없다고 생각한다.

단, 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다고 전제한다면 모든 변수를 불변으로 해도 무방하다. 하지만 현실은 타협이 필요하다.

이러한 타협 중 하나가 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.

`트랜잭션 메모리` 와 같은 실천법을 사용하여 동시 업데이트와 경험 조건 문제로부터 가변 변수를 보호할 수 있다.

현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 많은 코드를 빼내야 한다.

### 이벤트 소싱

트랜잭션 자체를 저장는 방법은 가변 변수가 하나도 필요 없게 된다. 무한한 저장 공간과 무한한 처리 능력이 필요하기 때문에 어떻게 보면 터무니 없을 수 있지만 이 전략이 영원히 동작하도록 만들 필요는 없다. 애플리케이션의 수명주기 동안만 문제 없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분하다.

`이벤트 소싱` 은 이러한 발상을 근원으로 상태가 아닌 트랜잭션을 저장하는 전략이다. 물론 저장 공간이 많이 필요하겠지만 현재에는 많은 저장 공간을 쉽게 구할 수 있게 되면서 불가능한 방법은 아니라고 생각한다.

저장소에서 삭제되거나 변경 없이 `CR`(create update)만 수행하며 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제(락) 또한 발생하지 않는다.

## 결론

이처럼 세 패러다임은 모두 우리에게서 무언가를 앗아갔다. 심지어 특정 패러다임은 무언가를 보태지도 않으며 오히려 뺏어간다.

이처럼 우리가 배운 것은 해서는 안되는 것에 대해서다. 만약 우리에게 패러다임이 오히려 자유로움을 준다면 어떨까? 상상만 해도 난잡해지고 소위 말하는 `괴물` 을 만들어 나갈 것이다. 패러다임이라는 규율을 통해 더 나은 방향으로 아키텍처를 설계하도록 인도하고 개발할 수 있도록 만들어 준다고 생각한다.

처음에 이러한 세 패러다임이 만들어지는 과정이 약 1950년도에 10년동안 만들어 진 것이라고 하였는데 소프트에어 즉 기술은 엄청 빠르게 발전하고 있다고 생각했지만 이러한 급격히 발전해 나가기 위해 버팀목이 되어 준 아키텍처(패러다임)은 급격히 발전하는 기술이 아니라는 걸 알 수 있었다. 다시 생각한다면, 쉽진 않겠지만 한번 클린 아키텍처에 대해 깨우칠 수 있다면 오랜기간 동안 큰 변함없이 사용할 수 있다는 의미라고 생각했다.

`소프트웨어는 순차, 분기, 반복, 참조로 구성되며 그 이상 그 이하도 아니다` 라는 말을 보고 반문을 들고 싶었지만 틀린 말은 아니라고 생각한다. 하지만 이러한 `순차, 분기, 반복, 참조` 를 어떻게 사용할 것이며 어떤 방법으로 구성할 것인지가 중요하고 이를 배워나가는 것이 클린 아키텍처라고 생각한다.