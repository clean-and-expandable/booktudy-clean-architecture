# 4부. 컴포넌트 원칙
SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다.

# 12장. 컴포넌트

잘 설계된 컴포넌트라면 반드시 독립적으로 배포가능하고, 개발 가능한 능력을 갖춰야 한다.

# 13장. 컴포넌트 응집도

- REP: 재사용/릴리스 등가 원칙
- CCP: 공통 폐쇄 원칙
- CRP: 공통 재사용 원칙

## REP: 재사용/릴리스 등가 원칙

소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고, 하지도 않을 것이다.

릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다.

새로운 릴리스가 나온다는 소식을 접하면, 개발자는 새 릴리스의 변경 사항을 살펴보고 기존 버전을 계속 쓸지 여부를 결정하곤 한다.

컴포넌트가 REP을 위배하면 컴포넌트 사용자가 알게 되고, 당신의 아키텍트로서의 능력을 높게 평하지 않을 것이다.

## CCP: 공통 폐쇄 원칙

동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

이 원칙을 SRP를 컴포넌트 관점에서 다시 쓴 것이다. SRP 에서 단일 클래스는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯이, 공통 폐쇄 원칙에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.

CCP는 변경될 가능성이 있는 클래스는 모두 한 곳으로 묶을 것을 권한다. 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다. 이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.

> 동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들을 서로 분리하라.
> 

## CRP: 공통 재사용 원칙

> 컴포넌트 사용자들은 필요하지 않는 것에 의존하게 강요하지 말라.
> 

CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.

개별 클래스가 단독으로 재사용되는 경우는 거의 없다. 대체로 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많다. CRP에서는 이런 클래스들이 동일한 컴포넌트에 포함되어야 한다고 말한다.

어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생겨난다. 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다. 또는 사용하는 컴포넌트를 변경하지 않더라도, 재컴파일, 재검증, 재배포를 해야 하는 가능성은 여전히 남아 있다. 심지어 사용되는 컴포넌트에서 발생한 변경이 사용하는 컴포넌트와는 전혀 관련 없는 경우라도 말이다.

CRP는 강하게 결합되지 않는 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다고 말한다.

**ISP와의 관계**

CRP는 인터페이스 분리 원칙의 포괄적인 버전이다. ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언한다. CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.

두 조언을 다음의 한 문장으로 요약할 수 있다.

> 필요하지 않는 것에 의존하지 말라.
> 

![image](https://user-images.githubusercontent.com/58139899/147716376-c4612ea1-bac6-49bf-94ed-cb9be321eb5f.png)

각 변은 반대쪽 꼭지점에 있는 원칙을 포기했을 때 감수해야 할 비용을 나타낸다.

프로젝트 현황에 따라 적절한 밸런스 조정이 중요하다.

(균형이 중요하다)

# 14장. 컴포넌트 결합

## ADP(Acyclic Dependencies Principle): 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.
> 

숙**취 증후군이란?**

의존하는 컴포넌트의 변화로 정상적이던 기능이 안되는 현상. 해결책은 두 가지로 주 단위 빌드와 의존성 비순환 원칙이다.

**주 단위 빌드**

주 5일 중 4일은 개발하고 나머지 하루는 싱크를 맞추는 것을 말한다. 근데 점차적으로 싱크에 소요하는 기간이 길어지게 된다.

**순환 의존성 제거하기**

개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다. 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.

담당 개발자는 이 컴포넌트에 릴리스 번호를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동 시킨다. 해당 릴리스를 사용할 지는 관련 팀에서 결정한다. 이 같은 작업 절차는 단순하며 합리적이어서 널리 사용되는 방식이다. 하지만 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성을 관리해야 한다. 의존성 구조에 순환이 있어서는 안 된다.

의존 순환이 있으면 DIP로 역전시킬 수 있다.

컴포넌트 구조는 흐트러짐과 확장, 순환 제거, 정리를 통해 성장한다.

**하향식 설계**

불가능.

## SDP: 안정된 의존성 원칙

> 안정성의 방향으로(더 안정된 쪽에) 의존하라
> 

설계는 결코 정적일 수 없다. 설계를 유지하다 보면 변경은 불가피하다. 공통 폐쇄 원칙을 준수함으로서, 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서도 특정 유형의 변경에만 민감하게 만들 수 있다.

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다. 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.

안정된 의존성 원칙을 준수하면 변경하기 어려운 모뎔이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

**안정성**

안정적이라는 말은 쉽게 움직이지 않는 이라는 뜻 이다.

A란 컴포넌트가 있을 때 다른 컴포넌트가 A 컴포넌트에 의존하면 안정적이고, A 컴포넌트가 다른 컴포넌트에 의존을 하면 안정적이지 않은 것이라고 볼 수 있다.

물론 모든 컴포넌트가 안정적일 필요는 없다.

## SAP: 안정된 추상화 원칙

컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

**고수준 정책을 어디에 위치시켜야 한다.**

비즈니스 로직이거나 중요한 것은 안정된 컴포넌트에 위치시켜야 한다.
