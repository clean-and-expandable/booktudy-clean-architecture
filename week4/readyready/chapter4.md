# 4주차

## 컴포넌트

- 잘 설계된 컴포넌트는 독립적으로  어떤 형태로든 배포가 가능하고 독립적으로 개발 가능한 능력을 갖춰야 한다.
- 기존에는 메모리 주소를 컴파일러에 알려주는 형태로 코딩을 하였고, 프로그램 위치가 한번 결졍되면 재배치가 불가능했다. 이 시대에는 장치는 느리고 메모리는 너무 비싸서 자원이 한정적이었기 때문에 불가피한 방법이었지만 문제가 있었다. 컴파일만 하는데 몇시간이 걸렸고 이를 해결한 방법이 함수 라이브러리의 소스코드를 애플리케이션 코드로부터 분리하는 방법이다. 함수 라이브러리를 개별적으로 컴파일하고, 컴파일된 바이너리를 메모리의 특정 위치에 로드했다. 하지만 애플리케이션은 점점 커졌고, 결국 할당 공간을 넘어서게 되었다. 이를 해결한 것이 `재배치가 가능한 바이너리` 였다. 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 방법이다. 오직 필요한 함수만 호출이 가능해졌고 이를 `링킹 로더` 라고 불렀다. 하지만 애플리케이션이 커질수록 시간이 오래걸리게 되었고 로드와 링크가 두 단계로 분리되어야 했다. 프로그래머가 느린 부분인 링크 과정을 링커를 통해 별도의 애플리케이션으로 작업을 처리하도록 만들었다.
- 이후에는 컴퓨터와 자치가 빨라져 또다시 로드와 링크를 동시에 할 수 있게 되었고 다수의 .jar 파일 또는 다수의 공유 라이브러리를 순식간에 서로 링크한 후 링크가 끝난 프로그램을 실행할 수 있게 되었다. 이게 바로 `플러그인 아키텍처` 이다.

## 컴포넌트 응집도

- 어떤 클래스를 어느 컴포넌트에 추가해야될지 고민을 많이 해봤을 것이다. 이러한 해결에 도움을 주는 것이 다음과 같은 세 가지 원칙이다.
    - REP: 재사용/릴리스 등가 원칙
    - CCP: 공통 폐쇄 원칙
    - CRP: 공통 재사용 원칙
- REP
    - 재사용 단위는 릴리스 단위와 같다.
    - 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수 없고, 하지도 않을 것이다. 이러한 당연한 것들이 REP 이다.
    - 하나의 컴포턴트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다.
    - 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다.
    - 이 원칙은 당연한 만큼 지키지 않으면 `이치에 맞지 않게 된다`
    - CCP와 CRP는 REP를 엄격하게, 하지만 제약을 가하는 측면에서 정의한다.
- CCP
    - 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.
    - 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
    - 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.
    - 대다수의 애플리케이션에서 유지보수성은 재사용서옵다 훨씬 중요하다. 애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.
    - 이를 통해 소프트웨어를 릴리스, 재검증, 재배포하는 일과 관련된 작업량을 최소화할 수 있다.
    - 발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀 있도록 설계해야 한다.
    - 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP 에서 얻은 교훈을 확대 적용한다. 따라서 변경이 필요한 요구사항이 발생했을 때, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다.
    - 동일한 시점에 동일한 이유로 변경되는 것들을 한데로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들을 서로 분리하라.
- CRP
    - 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
    - 같이 재사용되는 경향이 있는 클래스와 모듈들을 같은 컴포넌트에 포함해야 한다고 말한다.
    - 각 컴포넌트에 어떤 클래스들을 포함시켜야 하는지를 설명해주고 묶어서는 안되는 클래스가 무엇인지도 말해준다.
    - 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야 한다.
    - 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기한다.
    - 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 말한다.
    - 필요하지 않는 것에 의존하지 말라.
- 컴포넌트 응집도에 대한 균형 다이어그램
    - REP와 CCP 는 포함(inclusive) 원칙이다. 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다. CRP는 배제(exclusive) 원칙이며, 컴포넌트를 더 작게 만든다.
    - 이러한 삼각형태의 구조를 시간과 상황에 맞게 주의를 기울여야 한다. 프로젝트 초기에는 CCP가 REP보다 훨씬 더 중요한데, 개발 가능성이 재사용서옵다 더욱 중요하기 때문이다.
    - 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다. 프로젝트가 실제로 수행하는 일 자체보다는 프로젝트가 발전되고 사용되는 방법과 더 관련이 있다.

- 결론
    - 어느 클래스를 묶어서 컴포넌트로 만들지를 결정할 때 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다.
    - 시간이 흐름에 따라 프로젝트를 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화한다.
    

## 컴포넌트 결합

- 컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.

## ADP: 의존성 비순환 원칙

- 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.
    
    
- 순환 의존성 제거하기
    - 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
    - 의존성 구조에 순환이 있어서는 안된다.
    - 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다.
    - 비순환 방향 그래프다.
    - 순환은 즉각적인 문제를 일으킨다. 특정 컴포넌트를 사용하는 개발자들은 모두 서로에게 얽매이게 되는데, 모두 항상 정확하게 동일한 릴리스를 사용해야 하기 때문이다.
    - 테스트하는 과정에서도 순환 구조인 컴포넌트도 모두 테스트가 되어야 한다.
    - 뿐만 아니라 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기 상당히 힘들어진다.
    - 순환을 끊기 위해서는 다음과 같은 방법을 사용한다.
        - 의존성 역전 원칙(DIP)를 적용한다. 순환이 발생하는 클래스에 인터페이스를 생성하여 해당 인터페이스를 상속받고 의존성을 역전시킬 수 있다.
        - 순환되는 컴포넌트가 모두 의존하는 새로운 컴포넌트를 생성한다. 그리고 두 컴포넌트가 모두 의존하는 클래스를 새로운 컴포넌트로 이동시킨다.
- 하향식 설계
    - 컴포넌트 구조는 하향식으로 설계될 수 없다.
    - 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.
    - 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다. 바로 이러한 이유 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.
    - 의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다.
    - 컴포넌트 의존성 그래프는 자주 변경된느 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다.
    - 순환이 발생하면 ADP가 적용되고, 컴포넌트 의존성 그래프는 조금씩 흐트러지고 또 성장한다.
    - 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다.

## SDP: 안정된 의존성 원칙

- 안정성의 방향으로(더 안정된 쪽에) 의존하라.
    
    
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대 안 된다. 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.
- SDP를 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.
- 안정성
    - 안정성은 웹스터 사전에 `쉽게 움직이지 않는` 이라고 정의되어있다. 안정성은 변경을 만들기 위해 필요한 작업량과 관련된다.
    - 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 할 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.
    - 의존되는 것만 존재하는 컴포넌트는 책임지는 것이 많으며, 어디에도 의존하지 않으므로 변경되도록 만들 수 있는 외적인 영향이 전혀 없으므로 독립적이다.
    - 자신에게 의존하는 컴포넌트가 없으면 이 컴포넌트는 변경하지 말아야 할 이유가 없다. 반대로 이 컴포넌트가 다른 컴포넌트에 의존한다는 사실은 언젠가는 해당 컴포넌트를 변경해야 할 이유가 있다는 뜻이다.
    

## SAP: 안정된 추상화 원칙

- 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
    
    
- 고수준 아키텍처나 정책 결정과 관련된 소프트웨어는 자주 변경해서는 안 되는 소프트웨어이다. 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야 한다.
- 이러한 안정된 컴포넌트에 유연성을 주기위해 개방된 폐쇄 원칙(OCP)를 적용한다.
- 이 원칙을 준수할 수 있는 것이 추상(abstract)클래스이다.
- 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.
- SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지가 된다. 실제로 SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하며, SAP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문이다. 따라서 의존성은 추상화의 방향으로 향하게 된다.
- 엔티티는 `고통의 구역`에 위치하곤 한다. 데이터베이스가 이에 속하며 애플리케이션과 데이터베이스 사이에 위치한 인터페이스는 관리가 어렵다. String은 구체 클래스이며 굉장히 광범위하게 사용되기 때문에 변동성이 없다.
- 최고로 추상적이지만 누구도 그 컴포넌트에 의존하지 않는다면 `쓸모없는 구역`이라 한다.
- 주계열에 위치한 컴포넌트는 자신의 안정성에 비해 너무 추상적이지도 않고 추상화 정도에 비해 너무 불안정하지도 않은 곳이다.

- 결론
    - 의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 훌륭한 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.
    - 지표는 신이 아니므로 무언가 유용한 것을 찾을 수 있어야 한다.